# 兼容性

此页面提供了有关版本控制部分中提供的破坏性和非破坏性修改列表的详细说明。

什么算是一个破坏性（不兼容）的变化并不总是很清楚。这里的指南**应**被视为指示性的，而不是每一种可能变化的全面清单。

这里列出的规则只涉及客户端兼容性。希望API生产者明白在部署方面的要求，包括实施细节的变化。

一般目的是，服务更新minor或patch版本不该破坏客户端。考虑的破坏类型有：

* 源代码兼容性：针对1.0编写的代码无法在1.1版本编译
* 二进制兼容性：编译的1.0版本的库在1.1客户端库情况下无法链接/运行。（具体细节取决于客户端平台;在不同情况下有其变体）。
* 传输兼容性：针对1.0构建的应用程序无法与1.1服务器通信
* 语义兼容性：可以运行，但产生无意义的或令人惊讶的结果

换句话说：旧客户端应该能够在同一major版本号的较新服务器上工作，并且试图更新到新的minor版本（例如利用新功能）时，可以很容易做到。

除了理论上以外，有基于协议的考虑，也有实际存在的考虑， 客户端库涉及生成代码和手写代码。在可能的情况下，通过生成新版本的客户端库并确保其通过测试，以测试修改是否会破坏兼容性。

下面的讨论将原始消息分为三类：

* 请求消息（如GetBookRequest）
* 响应消息（如ListBooksResponse）
* 资源消息（例如Book，以及包括在其他资源消息中使用的任何消息）

这些类别具有不同的规则，因为请求消息只能从客户端发送到服务器，响应消息只能从服务器发送到客户端，但通常资源消息以两种方式发送。特别强调，对可更新的资源，需要根据读取/修改/写入周期来考虑。

## 向后兼容的修改

### 在API服务定义中添加API接口

从协议的角度来看，这始终是安全的。 唯一需要注意的是，客户端库可能已经在手写的代码中使用了您的新API接口名。 如果新接口与现有接口完全正交，~~这是不可能的~~; 如果新接口是现有接口的简化版本，则更有可能导致冲突。

### 向API接口添加方法

除非你添加的方法和客户端库已经生成的库冲突，否则应该没问题。

（如果你有一个GetFoo方法，C＃代码生成器已经创建了GetFoo和GetFooAsync方法，在API接口中添加一个GetFooAsync方法会出问题）。

### 给HTTP方法添加绑定

假设绑定不引入任何歧义，使服务器响应以前会拒绝的URL是安全的。 当将现有操作应用于新资源名称模式时，**可以**这样做。

### 向请求消息中添加字段

添加请求字段可以是兼容的，只要不指定该字段的客户端在新版和旧版中将视为一样。

最显而易见的反面例子是分页：如果v1.0的API不包括集合分页，则不能在v1.1中添加分页功能，除非默认page_size被视为无限大（这通常 一个坏主意）。 否则，希望在单个请求中获取完整结果的v1.0客户端可能会收到不完整的结果，而不知道结果集包含更多资源。

### 将字段添加到响应消息

不是资源（例如，ListBooksResponse）的响应消息可以扩展而不必破坏客户端，前提是不改变其他响应字段的行为。即使会引入冗余，先前在响应中填充的任何字段应继续使用相同的语义填充。

例如，1.0中的查询响应可能具有一个布尔字段contained_duplicates，以指示由于重复而忽略的结果。 在1.1中，我们可能会在duplicate_count字段中提供更详细的信息。 即使从1.1角度来看它是冗余的，仍然必须填充contained_duplicates字段。

### 给ENUM添加值

仅在请求消息中使用的枚举可以自由地扩展新元素。例如，使用资源视图模式，可以在新的minor版本中添加新视图。客户端从来不需要接收这个枚举，所以他们不必知道他们不关心的值。

对于资源消息和响应消息，缺省假设是客户端**应该**处理他们不知道的枚举值。然而，API生产者应该意识到，编写能正确处理新枚举元素的应用程序可能很困难。 API所有者应记录遇到未知枚举值时的预期的客户端行为。

Proto3允许客户端接收他们不知道的值，并保留保持相同值的消息，因此不会中断读/修改/写周期。 JSON格式允许在值的“名称”未知的情况下发送数值，但服务器通常不会知道客户端是否真正了解特定值。因此，JSON客户端可能意识到他们已经收到以前是未知的值，但JSON客户端只会看到名称或号码，而不会两者都知道。在读取/修改/写入周期中将相同的值返回到服务器不应该修改该字段，因为服务器应该理解这两种形式。

### 添加仅输出的资源字段

**可以**添加仅由服务器提供的资源实体中的字段。 服务器**可以**验证请求中的任何客户端提供的值是否有效，但是如果省略该值，服务器**必须**不会失败。

## 向后不兼容的修改

### 删除或重命名服务，字段，方法或枚举值

从根本上说，如果客户端代码可以引用某些东西，那么删除或重命名它是不兼容的变化，**必须**导致major版本增加。 引用旧名称的代码将导致某些语言（例如C＃和Java）在编译期出现故障，并可能导致其他语言的执行时失败或数据丢失。 传输格式兼容性与此无关。

### 修改HTTP绑定

“更改”在这里意味着有效地“删除和添加”。 例如，如果您确定要真正支持HTTP PATCH方法，但是您发布的版本支持PUT方法，或者您使用了错误的自定义动词名称，则可以添加新的绑定，但不能删除旧绑定，原因是删除服务方法是一个不兼容的变化。

### 更改字段的类型

即使新类型是传输格式兼容的，这也可能会导致客户端库生成的代码变化，因此必须增加Major版本。 对于编译型静态语言来说，会容易引入编译错误。

### 更改资源命名格式

资源不能使用其名称 - 这意味着集合名称不能更改。

与大多数不兼容更改不同，这也影响major版本：如果预期客户端使用v2.0 API访问在v1.0 API中创建的资源（反之亦然），则应在两个版本中使用相同的资源名称。

更细微地讲，有效资源名称的集合也**不应该**改变，原因如下：

* 如果变得更加严格，则以前成功的请求现在将失败。

* 如果它变得更宽松，那么基于前面文档做出的客户可能会被破坏。客户端很可能在其他地方存储资源名称，可能对允许的字符集和名称的长度敏感。或者，客户端可能正在执行自己的资源名称验证。 （例如，亚马逊给客户提供了很多警告，并且在允许更长的EC2资源ID前有个迁移期。）

注意，这样的改变只能在proto文档中可见。因此，当审查可能导致失败的CL时，仅检查非注释部分更改是不够的。

### 更改现有请求的可见行为

客户端通常依赖于API行为和语义，**即使这样的行为没有明确支持或记录**。 因此，在大多数情况下，更改API数据的行为或语义将被视为破坏消费者。 如果行为没有加密隐藏，您**应该**假设用户已经发现它，并将依赖于它。 例如，用户对AWS EC2资源标识符进行了逆向。

为此，加密分页令牌（即使数据不感兴趣）是一个好主意，以防止用户创建自己的令牌，并且当令牌行为改变时可能被破坏。

### 更改HTTP定义中的URL格式

除了上面列出的资源名称修改外，有两种修改需要考虑：

* 自定义方法名称：虽然不是资源名称的一部分，但自定义方法名称是REST客户端发布到的URL的一部分。 更改自定义方法名称不应破坏gRPC客户端，但公共API必须假定它们具有REST客户端。

* 资源参数名称：从v1/shelves/{shelf}/books/{book}更改为v1/shelves/{shelf_id}/books/{book_id}不会影响替代资源名称，但可能会影响代码生成。

### 向资源消息添加读/写字段

客户端将经常执行读/修改/写操作。 大多数客户端不会为他们不知道的字段提供值，而且proto3不支持。 您可以指定任何缺少消息类型的字段（而不是原始类型），这意味着更新不适用于这些字段，也使得从实体中显式移除该字段值变得更加困难。 原始类型（包括字符串和字节）不能这样处理，因为在显式指定int32字段为0和没有指定之间，proto3的表现没有什么不同。

如果使用字段掩码执行所有更新，这就不是问题，因为客户端不会隐式地覆盖其不知道的字段。 然而，这将是一个不寻常的API决策：大多数API允许“整个资源”更新。


